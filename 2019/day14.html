<html>

<body>
    <script>
        const reactionString = `2 LFPRM, 4 GPNQ => 2 VGZVD
1 KXFHM, 14 SJLP => 8 MGRTM
2 HBXVT, 3 HNHC, 5 BDLV => 1 DKTW
2 MGRTM, 8 RVTB => 4 DFMW
2 SJLP => 9 PXTS
1 NXBG => 6 FXBXZ
32 LPSQ => 9 GSDXD
13 LZGTR => 4 ZRMJ
1 FTPQ, 16 CPCS => 5 HNHC
2 THQH, 2 NDJG, 5 MSKT => 4 LRZV
2 BDLV, 9 HBXVT, 21 NXBG => 7 PLRK
16 LNSKQ, 41 KXFHM, 1 DKTW, 1 NCPSZ, 3 ZCSB, 11 MGRTM, 19 WNJWP, 11 KRBG => 1 FUEL
5 FTPQ, 1 HBXVT => 4 BDLV
15 LSDX, 1 GFJW, 1 QDHJT => 4 NKHQV
9 CZHTP, 1 FRPTK => 6 SNBS
17 LFLVS, 2 WCFT => 8 KGJQ
6 CMHLP => 1 SJLP
144 ORE => 3 KQKXZ
3 GFJW, 1 RVTB, 1 GPNQ => 2 NXBG
4 BDLV => 5 CMHLP
2 LSDX => 1 LZGTR
156 ORE => 3 NDJG
136 ORE => 8 MSKT
4 BDLV, 1 NKHQV, 1 RVTB => 7 LNSKQ
1 LRZV, 3 WCFT => 2 HBXVT
5 KGJQ, 1 SWBSN => 7 QHFX
2 DQHBG => 4 LPSQ
6 GSDXD => 3 LSDX
11 RWLD, 3 BNKVZ, 4 PXTS, 3 XTRQC, 5 LSDX, 5 LMHL, 36 MGRTM => 4 ZCSB
8 CPCS => 2 FRPTK
5 NDJG => 3 WCFT
1 GDQG, 1 QHFX => 4 KXFHM
160 ORE => 3 THQH
20 GFJW, 2 DQHBG => 6 RVTB
2 FXBXZ, 1 WNJWP, 1 VGZVD => 5 RWLD
3 DQHBG => 7 SWBSN
7 QHFX => 8 CPCS
14 HBXVT => 3 VCDW
5 FRPTK => 7 NGDX
1 HWFQ => 4 LFLVS
2 CPCS => 6 ZTKSW
9 KGJQ, 8 ZTKSW, 13 BDLV => 6 GDQG
13 LMHL, 1 LZGTR, 18 BNKVZ, 11 VCDW, 9 DFMW, 11 FTPQ, 3 RWLD => 4 KRBG
1 XRCH => 7 GPNQ
3 WCFT => 9 DQHBG
1 FTPQ => 8 CZHTP
1 PBMR, 2 ZTKSW => 2 BNKVZ
2 PLRK, 3 CPCS => 8 ZSGBG
3 NGDX, 3 XRCH => 6 XTRQC
6 ZTKSW, 11 HNHC, 22 SNBS => 9 WNJWP
5 KQKXZ => 8 HWFQ
23 WCFT => 7 PBMR
1 LRZV, 1 QDHJT => 2 GFJW
1 ZSGBG, 5 CGTHV, 9 ZRMJ => 3 LMHL
1 DQHBG => 9 XRCH
1 GDQG, 17 RWLD, 2 KGJQ, 8 VCDW, 2 BNKVZ, 2 WNJWP, 1 VGZVD => 3 NCPSZ
19 SJLP, 3 ZTKSW, 1 CZHTP => 4 LFPRM
14 SNBS => 8 CGTHV
3 DQHBG, 4 WCFT => 1 FTPQ
3 MSKT, 3 NDJG => 5 QDHJT`;
        /*
        2 LFPRM, 4 GPNQ => 2 VGZVD
1 KXFHM, 14 SJLP => 8 MGRTM
2 HBXVT, 3 HNHC, 5 BDLV => 1 DKTW
2 MGRTM, 8 RVTB => 4 DFMW
2 SJLP => 9 PXTS
1 NXBG => 6 FXBXZ
32 LPSQ => 9 GSDXD
13 LZGTR => 4 ZRMJ
1 FTPQ, 16 CPCS => 5 HNHC
2 THQH, 2 NDJG, 5 MSKT => 4 LRZV
2 BDLV, 9 HBXVT, 21 NXBG => 7 PLRK
16 LNSKQ, 41 KXFHM, 1 DKTW, 1 NCPSZ, 3 ZCSB, 11 MGRTM, 19 WNJWP, 11 KRBG => 1 FUEL
5 FTPQ, 1 HBXVT => 4 BDLV
15 LSDX, 1 GFJW, 1 QDHJT => 4 NKHQV
9 CZHTP, 1 FRPTK => 6 SNBS
17 LFLVS, 2 WCFT => 8 KGJQ
6 CMHLP => 1 SJLP
144 ORE => 3 KQKXZ
3 GFJW, 1 RVTB, 1 GPNQ => 2 NXBG
4 BDLV => 5 CMHLP
2 LSDX => 1 LZGTR
156 ORE => 3 NDJG
136 ORE => 8 MSKT
4 BDLV, 1 NKHQV, 1 RVTB => 7 LNSKQ
1 LRZV, 3 WCFT => 2 HBXVT
5 KGJQ, 1 SWBSN => 7 QHFX
2 DQHBG => 4 LPSQ
6 GSDXD => 3 LSDX
11 RWLD, 3 BNKVZ, 4 PXTS, 3 XTRQC, 5 LSDX, 5 LMHL, 36 MGRTM => 4 ZCSB
8 CPCS => 2 FRPTK
5 NDJG => 3 WCFT
1 GDQG, 1 QHFX => 4 KXFHM
160 ORE => 3 THQH
20 GFJW, 2 DQHBG => 6 RVTB
2 FXBXZ, 1 WNJWP, 1 VGZVD => 5 RWLD
3 DQHBG => 7 SWBSN
7 QHFX => 8 CPCS
14 HBXVT => 3 VCDW
5 FRPTK => 7 NGDX
1 HWFQ => 4 LFLVS
2 CPCS => 6 ZTKSW
9 KGJQ, 8 ZTKSW, 13 BDLV => 6 GDQG
13 LMHL, 1 LZGTR, 18 BNKVZ, 11 VCDW, 9 DFMW, 11 FTPQ, 3 RWLD => 4 KRBG
1 XRCH => 7 GPNQ
3 WCFT => 9 DQHBG
1 FTPQ => 8 CZHTP
1 PBMR, 2 ZTKSW => 2 BNKVZ
2 PLRK, 3 CPCS => 8 ZSGBG
3 NGDX, 3 XRCH => 6 XTRQC
6 ZTKSW, 11 HNHC, 22 SNBS => 9 WNJWP
5 KQKXZ => 8 HWFQ
23 WCFT => 7 PBMR
1 LRZV, 1 QDHJT => 2 GFJW
1 ZSGBG, 5 CGTHV, 9 ZRMJ => 3 LMHL
1 DQHBG => 9 XRCH
1 GDQG, 17 RWLD, 2 KGJQ, 8 VCDW, 2 BNKVZ, 2 WNJWP, 1 VGZVD => 3 NCPSZ
19 SJLP, 3 ZTKSW, 1 CZHTP => 4 LFPRM
14 SNBS => 8 CGTHV
3 DQHBG, 4 WCFT => 1 FTPQ
3 MSKT, 3 NDJG => 5 QDHJT`;

        /*
        10 ORE => 10 A
        1 ORE => 1 B
        7 A, 1 B => 1 C
        7 A, 1 C => 1 D
        7 A, 1 D => 1 E
        7 A, 1 E => 1 FUEL`;*/

        const parseReactions = function (string) {
            const reactions = [];
            const lines = string.split("\n");
            lines.forEach(a => {
                const aa = a.split("=>");
                const product = aa[1].trim().split(" ");
                const requires = aa[0].split(",");
                const prodQ = parseInt(product[0].trim());
                const prodT = product[1].trim();
                if (reactions[prodT] != null) throw "erm!!";
                reactions[prodT] = {
                    quantity: prodQ, requires: requires.map(a => {
                        const req = a.trim().split(" ");
                        const reqQ = parseInt(req[0].trim());
                        const reqT = req[1].trim();
                        return { require: reqT, quantity: reqQ };
                    })
                };
            })
            return reactions;
        }

        let ores = 0;
        let spares = {};

        const getRequirements = function (reactions, startWith = "FUEL", quantity = 1, level = "-") {
            let numberWeNeed = quantity;
            //console.log(level + "Getting requiremets for " + numberWeNeed + " " + startWith);
            const requirementsForThis = reactions[startWith];
            const numberWeHaveToMake = requirementsForThis.quantity;
            //console.log(level + "We have to make " + numberWeHaveToMake);
            if (spares[startWith] != null && spares[startWith] > 0) {
                //console.log(level + "using spares");
                if (spares[startWith] > numberWeNeed) {
                    //console.log(level + "all " + numberWeNeed + " available in spares");
                    spares[startWith] -= numberWeNeed;
                    numberWeNeed = 0;
                } else {
                    //console.log(level + "just " + spares[startWith] + " available in spares");
                    numberWeNeed -= spares[startWith];
                    spares[startWith] = 0;
                }
            }
            if (numberWeNeed > 0) {
                const rounds = Math.ceil(numberWeNeed / numberWeHaveToMake);
                requirementsForThis.requires.forEach(a => {
                    let localQuantity = quantity;
                    //console.log(level + a.quantity + " " + a.require);
                    if (a.require != "ORE") {
                        getRequirements(reactions, a.require, (rounds * a.quantity), level + "-");
                    } else {
                        ores += (rounds * a.quantity);
                    }
                });
                numberWeNeed -= (numberWeHaveToMake * rounds);
            }
            if (numberWeNeed < 0) {
                //console.log(level + "we have " + Math.abs(numberWeNeed) + " spares of " + startWith);
                if (spares[startWith] == null) spares[startWith] = 0;
                spares[startWith] -= numberWeNeed;
            }

        }



        /*
        const getOres = function (reactions, startWith = "FUEL") {
            const reqs = getRequirements(reactions, startWith);
            console.log("Processing requirements for " + startWith);
            processRequirements(reactions, reqs, 1);
        }
 
        const processRequirements = function (reactions, reqs, quantity) {
            reqs.requires.forEach(r => {
                let required = r.quantity;
                if (spares[r.require] != null && spares[r.require] > 0) {
                    if (spares[r.require] > required) {
                        spares[r.require] -= required;
                        required = 0;
                    } else {
                        required -= spares[r.require];
                        spares[r.require] = 0;
                    }
                }
                if (required > 0) {
                    if (r.require == "ORE") {
                        console.log(required);
                        console.log(quantity);
                        console.log("Requiring " + (required) + "OREs");
                        ores += quantity;
                        required -= quantity;
                        if (required <= 0) {
                            if (spares[r.require] == null) spares[r.require] = 0;
                            spares[r.require] -= required;
                            console.log("spares " + spares[r.require]);
                        }
                    } else {
                        console.log(required);
                        console.log(quantity);
                        console.log("Requiring " + (required) + r.require);
                        const rs = getRequirements(reactions, r.require);
                        console.log("Processing requirements for " + r.require);
                        processRequirements(reactions, rs, required);
                    }
                }
            });
        }
 
        const getRequirements = function (reactions, forProduct) {
            const requirements = [];
            if (reactions[forProduct] != null) {
                /*const thisReaction = reactions[forProduct];
                console.log(thisReaction);
                if (spares[thisReaction.require] != null && spares[thisReaction.require] > 0) {
                    if (spares[thisReaction.require] > forQuantity) {
                        spares[thisReaction.require] -= forQuantity;
                        return requirements;
                    } else {
                        forQuantity -= spares[thisReaction.require];
                        spares[thisReaction.require] = 0;
                    }
                }
                while (forQuantity > 0) {
                    forQuantity -= thisReaction.quantity;
                    requirements.push(thisReaction);
                    if (forQuantity <= 0) {
                        if (spares[thisReaction.require] == null) spares[thisReaction.require] = 0;
                        spares[thisReaction.require] -= forQuantity;
                        break;
                    }
                }
                return reactions[forProduct];
            } else throw "not available" + forProduct;
            return requirements;
        }
*/

        const r = parseReactions(reactionString);
        let fuelsMade = 0;

        getRequirements(r, "FUEL");
        const oresForOne = ores;
        const trillion = 1000000000000;
        const numbersThatFitsIntoTrillion = trillion / oresForOne;
        let numberToTry = numbersThatFitsIntoTrillion;
        while (true) {
            console.log("numberToTry is " + numberToTry);
            ores = 0;
            spares = {};
            getRequirements(r, "FUEL", numberToTry);
            let theseOres = ores;
            if (theseOres <= trillion) {
                ores = 0;
                spares = {};
                getRequirements(r, "FUEL", numberToTry + 1);
                if (ores > trillion) {
                    break;
                }
            }
            const difference = trillion / ores;
            console.log("ores is " + ores);
            console.log("difference is " + difference);
            let newNumberToTry = Math.floor(numberToTry * difference); 
            if (newNumberToTry == numberToTry) numberToTry += 1; else numberToTry = newNumberToTry;
        }
        console.log("here");

    </script>

</body>

</html>